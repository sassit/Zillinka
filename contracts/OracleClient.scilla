scilla_version 0

(**********************************************************************************)
(* OracleClient:                                                                  *)
(*  request data from an Oracle and receive it back in a callback:                *)
(*    callback_data(id: String, data: Uint32, argument: String)                   *)
(*  oracles are smart contracts on a certain address, identified by a string id   *)
(*  and offering a transition: request(arg: String)                               *)
(**********************************************************************************)

(*import ListUtils IntUtils BoolUtils *)

library OracleClient

let zero128 = Uint128 0 (* used for zero amounts *)

let one_msg = (* Wrap single message into singleton list *)
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

contract OracleClient
()

(* addresses of different oracles, identified by a string *)
field oracles : Map String ByStr20 = Emp String ByStr20
(* store all data received from all oracles *)
field all_data : Map String (Map String Uint32) = Emp String (Map String Uint32)(* m[oracle_id][argument] = level *)

(* @notice: request data from an oracle          *)
(* @param:  oracle_id : string to identify the oracle   *)
transition data_request(oracle_id : String, arg: String)
  to_o <- oracles[oracle_id]; (* Option ByStr20 *)
  match to_o with
  |None =>
    err = {_exception: "data_request: no oracle with given id available"; oracleId: oracle_id};
    throw err
  |Some addr => (* send a message to the oracle to request data, given a string argument *)
    ev = {_eventname : "data_request"; oracleAddress: addr; argument: arg};
    event ev;
    msg = {_tag: "request"; _recipient: addr; _amount: zero128 ; arg: arg};
    msgs = one_msg msg;
    send msgs
  end (* to_o *)
end


(* @notice: add an oracle contract to the map. Will request the oracle's id *)
(*          and add it to the map upon receiving the id back                *)
(* @param:  address : oracle contract's address                             *)
transition add_oracle(address : ByStr20)
  (* get the oracles's id to store it in the map upon callback *)
  msg = {_tag: "get_id"; _recipient: address; _amount: zero128};
  msgs = one_msg msg;
  send msgs
end

(* @notice: delete an oracle contract from the map  *)
(* @param:  id : string to identify an oracle       *)
transition delete_oracle(oracle_id : String)
  delete oracles[oracle_id]
end

(* @notice: callback function that oracle calls with its id when asked for it *)
transition callback_id(oracle_id: String)
  ex <- exists oracles[oracle_id];
  match ex with
  |True => (* cannot add, already exists *)
    err = {_exception: "callback_id: oracle with this id already exists. Use delete first in order to replace"};
    throw err
  |False =>
    oracles[oracle_id] := _sender;
    e = {_eventname : "callback_id: added"; oracleAddress: _sender; oracleIdReceived: oracle_id};
    event e
  end (* ex *)
end

(* @notice: callback function that oracle calls with the data when asked for it *)
transition callback_data(oracle_id: String, data: Uint32, argument: String)
  all_data[oracle_id][argument] := data; (* store and emit *)
  ev = {_eventname : "callback_data"; oracleId: oracle_id; argument: argument; data: data};
  event ev
end
