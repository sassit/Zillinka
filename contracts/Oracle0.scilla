scilla_version 0

(***********************************************************************************)
(* Oracle: serves client requests through transition: request(arg: String)         *)
(*         emits an event with the request details                                 *)
(*         receives data through set_data(arg: String, data: Uint32) and calls the *)
(*         the client back by sending a message to its callback:                   *)
(*           callback_level(id: String, level: Option Uint32, argument: String))   *)
(***********************************************************************************)

(*import ListUtils IntUtils BoolUtils *)

library Oracle0

let zero128 = Uint128 0 (* used for zero amounts *)

type Job = (* requestor, argument *)
  | Job of ByStr20 String

let get_requestor = fun(job: Job) =>
  match job with
  | Job requestor argument => requestor
  end

let get_argument = fun(job: Job) =>
  match job with
  | Job requestor argument => argument
  end

let one_msg = (* Wrap single message into singleton list *)
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

contract Oracle0
(id: String)

field next_job_id: Uint32 = Uint32 0 (* keep track of requests by increasig the counter *)
field jobs: Map Uint32 Job = Emp Uint32 Job (* m[req_id] = (requestor, argument) *)


(* @notice: request data from an oracle                 *)
(* @param:  arg: any arguments needed in a string       *)
transition request(arg: String)
  job_id <- next_job_id;
  job = Job _sender arg;
  jobs[job_id] := job;
  one32 = Uint32 1;
  next_id = builtin add job_id one32;
  next_job_id := next_id;
  e = {_eventname : "request"; oracle_id: id; job: job_id; requestor: _sender; argument: arg};
  event e
end

(* @notice: request id from an oracle. id sent back through callback *)
transition get_id()
  e = {_eventname : "get_id"; oracle_id: id; requestor: _sender};
  event e;
  msg = {_tag: "callback_id"; _recipient: _sender; _amount: zero128 ; id: id};
  msgs = one_msg msg;
  send msgs
end

(* @notice: give the oracle some (off-chain) data               *)
(* @param:  data : the data (e.g. a gauge level)                *)
(* @param:  req_id: the (for this oracle) unique request id     *)
transition set_data(data: Uint32, job_id: Uint32)
  e = {_eventname : "set_data"; oracle_id: id; job: job_id; data: data};
  event e;
  job_o <- jobs[job_id];
  match job_o with
  |None =>
    err = {_exception: "set_data: job/request does not exist in map"; oracle: id; job: job_id};
    throw err
  |Some job => (* emit and callback the requestor with the data *)
    to = get_requestor job;
    arg = get_argument job;
    msg = {_tag: "callback_data"; _recipient: to; _amount: zero128 ; id: id; data: data; argument: arg};
    msgs = one_msg msg;
    send msgs
  end (* job_o *)
end
