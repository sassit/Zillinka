scilla_version 0

(***********************************************************************************)
(* Oracle: serves client requests through transition: request(arg: String)         *)
(*         emits an event with the request details, stores the request internally  *)
(*         by assigning it a request_id storing the initiator (the client's addr)  *)
(*         and the argument received with the request                              *)
(*         receives data through set_data(arg: String, request_id: Uint32)         *)
(*         the client back by sending a message to its callback:                   *)
(*           callback_data(oracle_id: String, data: Uint32, argument: String)      *)
(***********************************************************************************)

(*import ListUtils IntUtils BoolUtils *)

library Oracle0

let zero128 = Uint128 0 (* used for zero amounts *)

type DataRequest = (* requestor, argument *)
  | DataRequest of ByStr20 String

let get_requestor = fun(request: DataRequest) =>
  match request with
  | DataRequest requestor argument => requestor
  end

let get_argument = fun(request: DataRequest) =>
  match request with
  | DataRequest requestor argument => argument
  end

let one_msg = (* Wrap single message into singleton list *)
  fun (msg : Message) =>
    let nil_msg = Nil {Message} in
    Cons {Message} msg nil_msg

contract Oracle0
(oracle_id: String)

field next_request_id: Uint32 = Uint32 0 (* keep track of requests by increasig the counter *)
field data_requests: Map Uint32 DataRequest = Emp Uint32 DataRequest (* m[req_id] = (requestor, argument) *)


(* @notice: request data from an oracle                 *)
(* @param:  arg: any arguments needed in a string       *)
transition request(arg: String)
  request_id <- next_request_id;
  request = DataRequest _sender arg;
  data_requests[request_id] := request;
  one32 = Uint32 1;
  next_id = builtin add request_id one32;
  next_request_id := next_id;
  ev = {_eventname : "request"; oracleId: oracle_id; requestId: request_id; initiator: _sender; argument: arg};
  event ev
end

(* @notice: request id from an oracle. id sent back through callback *)
transition get_id()
  e = {_eventname : "get_id"; oracleId: oracle_id; requestor: _sender};
  event e;
  msg = {_tag: "callback_id"; _recipient: _sender; _amount: zero128 ; oracle_id: oracle_id};
  msgs = one_msg msg;
  send msgs
end

(* @notice: give the oracle some (off-chain) data               *)
(* @param:  data : the data (e.g. a gauge level)                *)
(* @param:  req_id: the (for this oracle) unique request id     *)
transition set_data(data: Uint32, request_id: Uint32)
  ev = {_eventname : "set_data"; oracleId: oracle_id; requestId: request_id; data: data};
  event ev;
  job_o <- data_requests[request_id];
  match job_o with
  |None =>
    err = {_exception: "set_data: request does not exist in map"; oracleId: oracle_id; requestId: request_id};
    throw err
  |Some request => (* emit and callback the requestor with the data *)
    to = get_requestor request;
    arg = get_argument request;
    msg = {_tag: "callback_data"; _recipient: to; _amount: zero128 ; oracle_id: oracle_id; data: data; argument: arg};
    msgs = one_msg msg;
    send msgs
  end (* job_o *)
end
